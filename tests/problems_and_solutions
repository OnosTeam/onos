0)what happen if onos try to write to node which is offline? :
  onos will try n times and after that it will give up ,the relative onos object will remain in wait status 
    it is usefull to make a flag on the onos node ...at start time each hwnode will ask onos for the pin config 
    when this happen the flag has to be setted to active=1  ,on onos reboot all theese flag will be cleared.
    So onos know which nodes have been active after its boot
    see point 34


1)what happen if onos try to write to node which is asking onos for pins config?
  onos will try n times and after that it will give up ,the relative onos object will not change status 

onos allarms must remain active also if the current went out 

2)i will use http://www.arduino.cc/en/Reference/Servo   for the servos control but when you use one or more servo you will not be able to use analog out  pins
  onos must block the user to make this.
  

3)the analog pin can't be used as digital and then reused for analog unless you reboot arduino:
  the pin setup is done only on arduino boot , so there is no problem 


4)the pin setup need to be improved because it's not compact:
  no problem , each node tells onos its serial number and its node_fw
  (if the node_fw number is newer use the new method else use the old one)

5)need to encode the pin setup in a simple and compact way: deprecated
#  here the protocol:
#  start with 's='
#  then  add    9 bytes that rappresent the pin used (1 for pin used 0 for not used)   
#  after that   9 bytes that rappresent the digital pin setup from pin0 to pin 72 (8*9=72) , where 1 is output ,0 is input
#  after that   9 bytes that tell arduino which pin to set as analog input
#  after that   9 bytes that tell arduino which pin to set as pwm output
#  after that   9 bytes that tell arduino which pin to set as servo output
#  then  3   bytes to close the packet '_#]'
#  example:"s=000000000000000000000000000000000000000000000_#]"  the 0 are not 0 but the value corrisponding to ascii '0'
    # total 50 byte 


5 New)Need a simpler way to code the setup:

# here a protocol we could use:#not implemented
# start with 's='
# then  add    1 byte to tell the msg length
# then  add    1 byte to tell the pin number (from 0 to 255) 
# after that   1 byte to tell the pin type ( digital out, digital in,set/reset relay,analog input,pwm output,servo output)
# after that   1 byte to tell the pin starting status from 0 to 255 (the pin will be setted to this status )
# then repeat for the other pins leving out the "s=" and the msg lenght


6)in arduino analogRead(0) ,0 does't refer to the digital pin 0 of the arduino but to the analogpin 0 of arduino:
  when you try to read an analog pin you will have to use the real arduino number so:
  static const uint8_t A0 = 14;
  static const uint8_t A1 = 15;
  static const uint8_t A2 = 16;
  static const uint8_t A3 = 17;
  static const uint8_t A4 = 18;
  static const uint8_t A5 = 19;
  static const uint8_t A6 = 20;
  static const uint8_t A7 = 21;
  if you want to read the analog value of analog 0 pin  you have to set the pin 14 as analoginput in the onos node
  an alternative is to make a dict only used by analogread function  ,maybe in the future



7)when an arduino node read a change in a pin then execute a query like /onos_cmd==setnodepin_  
  then onos change all the webobjects status which have the pin of this node in their class doing so 
  you can't have object that reads more than one pin ,
  instead you can have webobject that set more than a pin at a time , like sr_relay .

    problem not solved for now you can't have sensor object with more than a pin attached , maybe a solution is to made
    a scenario which use the data from two or more objects in order to set another objects status

8)the user can setup a pin with more than one mode in the hardwareModelDict  
    for now the problem exist...banana to solve later


9) Deprecated
    Each node has to send the change status of a pin to onos webserver but some nodes can have up to 72 status to send.
    Every times a pin status changes the node will send 9 byte containing the digital status of the 72 pins , 
    onos then will compare the data to the hardware model of the node type and discover 
    what are really used as digital input , then it will change each relative webobject using the method
    changeWebObjectStatus(objName,statusToSet,write_to_hardware)  setting the write_to_hardware flag to 0 
    for the analog there will be only a maximun of 16 analog input (arduino mega)
    adc on arduino are 10bit so to store a value you need 2 byte (an uint16_t  or short variable)
    so there will be an array of uint16_t  containing the 16 analog input
    every time an adc value change from the old one by a threshold (25 which is a change by 0,122 volts )
    the node will send to the server the message to change all the webobjects status which have this analog pin attached.
    so the register used on arduino will be:  
     10 bytes for the digital status (9+ 1 void to close the array),
     10 bytes for the digital setup pins(9+ 1 void to close the array) (to know which pin to read) 
     10 bytes to store the analog pin setup(9+ 1 void to close the array) (which of the 16 pin is used as analog input)     
     33 bytes for the analog status.
     total 70 bytes

     the protocol for data trasmission from arduino to onos webserver will be:
     "onos"+node_code_name+node_fw+"d"+d_status_string+"a"+a_status_string+"_#]"
     where :
     "onos": 4 byte long  told onos the packet start
     node_code_name is 12 bytes long like :"ProminiA0002"
     node_fw is  4 bytes long  like :"4.99"
     "d":  1 byte long  tell the follower string is a digital register
     d_status_string is 9 bytes long and each byte is a char with the value of 8 bits in the registers status 
     "a":  1 byte long  tell the follower string is an analog register
     a_status_string is 32 bytes long and each 2 bytes contain an analog value
     "_#]"  3 byte long  to tell onos end of packet  

   




10)How to insert fastly a serial number in the onos router? 


11)If the onos webserver is rebooted after crash but the hw nodes are not , they continue to think onos has the node data.
   but onos forgot it.
     make the onos webserver create the node class again also from the setnode pin query


12)Is difficult to make a onos node that will act as server and also as client 
   because while the node is writing the pin status to the server , the server can't change the pin status on the node.
     the solution is to have different node types :
     The nodes with fast data read update which will have a fast data reading update and a slow act on query(turn on things)
     The nodes with slow data reading which will give the onos server the data only when requested or every n minutes
     this type will be used to execute task like turn on the light after received the query from the onos webserver


13)Arduino send binary data but onos give error sometimes:

192.168.0.15 - - [29/Mar/2015 13:34:53] code 400, message Bad request version ('0000470180204603501150702\x00%\x00\x00%\x00%\xa1+\x13%+\x13\x00\x085+\x13\x00\x08Q')
I will use post instead of get message


14)If a node lost connection to the router and then regain connection...then the node ip will change and the webserver will still think that node has the old ip:
  the nodes will contact the onos webserver every  n minutes.
  Onos will start a query to a node with the node serial number so 
  the node will do nothing if received a message with the wrong serial number and will tell that to onos.


15) if a post request is made and then broken onos will wait forever..
   banana not solved yet



16)Onos need a protocol to talk with the nodes.
  here the protocol:
  The message will have a variable lenght from a minimum of 11 bytes to a maximun of 61 bytes. 
  The start of each message will be indicated by a 3 bytes long string equal to "[S_" 
  The end of each message will be indicated by a 3 bytes long string equal to "_#]"  
  After the start of the message the first 3 bytes contain the address to whom the message is directed.
  After the address bytes 2 bytes will tell the type of the message.
  The remaining bytes of the message will have different lenght,meaning and position based on the type of the message.

  Example of the smallest possible message:
    [S_001ka_#] 
  


  To handle errors cmd:

  If a node A recived a cmd it doesn't recognise from node B (because is not implemented in that node)  it will not send an ack...

  The node B will retry n times to transmit and wait for an ack from nodeA and after that (if it still hasn't received an ack from node A)  it will wait listening for a possible answer for n milliseconds.
  Node A after the first message  received from node B started to try to send the error code to node B waiting for an ack

  alternative : each time the node write to another node it will wait for an answer..not just   



 
  Standard part to all messages :

  "[S_"   3 byte for the start of the message
   3 bytes for the address of the node
   2 bytes for the type of msg
   1 bytes for the message id (a progressive number from 0 to 255 to identify the message, first time will be 0 next 1 and so on...all in binary data)
  "#_]"   3 byte for the end of the message






  

  The message to change a digital output pin status will be:

  3 bytes with "[S_" for the start of the message
  3 bytes for the address of the node
  2 bytes containing "dw" for the type of msg
  2 bytes for the number of pin  (for pin 13 it will be '13'  ,for pin 3 it will be '03')
  3 bytes to tell arduino the status (000 or 001 ) to set the pin
  1 bytes for the message id ,a progressive binary number from 0 to 255
  3 bytes with "_#]" to close the message 
  example:   [S_001dw06001x_#]    to set pin 6 to 1
             [S_001dw06000x_#]    to set pin 6 to 0





  The message to change an analog output pin status will be: 

  3 bytes with "[S_" for the start of the message
  3 bytes for the address of the node
  2 bytes containing "aw" for the type of msg
  2 bytes for the number of pin  (for pin 10 it will be '10'  ,for pin 3 it will be '03')
  3 bytes to tell arduino the status (from 000 to 255 ) to set the pin
  1 bytes for the message id ,a progressive binary number from 0 to 255
  3 bytes with "_#]" to close the message 
  example:   [S_001aw06155x_#]    to set analog pin 6 to 155



  The message to change a servomotor position will be: 

  3 bytes with "[S_" for the start of the message
  3 bytes for the address of the node
  2 bytes containing "sm" for the type of msg
  2 bytes for the number of pin  (for pin 10 it will be '10'  ,for pin 3 it will be '03')
  3 bytes to tell arduino the position (from 000 to 180 ) to set the servo motor
  1 bytes for the message id ,a progressive binary number from 0 to 255
  3 bytes with "_#]" to close the message 
  example:   [S_001sm11135x_#]    to set servo motor pin 1 to 135




  The message to change a set/reset latch relay status will be: 

  3 bytes with "[S_" for the start of the message
  3 bytes for the address of the node
  2 bytes containing "sr" for the type of msg
  4 bytes for the number of pins  (for pin 4 as set and pin 5 as reset it will be '0405')
  1 byte to tell arduino the value (0 or 1 ) to set the relay
  1 bytes for the message id ,a progressive binary number from 0 to 255
  3 bytes with "_#]" to close the message 
  example:   [S_001sr04051x_#]    to set the relay (set on pin 4 , reset on pin 5)  to 1
             [S_001sr04050x_#]    to set the relay (set on pin 4 , reset on pin 5)  to 0 





  The message to change the status of the onos_plug_node_WPlugavx contact status will be: 

  3 bytes with "[S_" for the start of the message
  3 bytes for the address of the node
  2 bytes containing "wp" for the type of msg , command wireless plug node
  1 bytes for the number of the object to controll (for first object of the node it will be "0" and it will be the contact status)
  1 byte to tell arduino the value (0 or 1 ) to set the object
  1 bytes for the message id ,a progressive binary number from 0 to 255
  3 bytes with "_#]" to close the message 
  example:   [S_001wp01x_#]    to set the first object of the node to 1
             [S_001wp00x_#]    to set the first object of the node to 0


  The message to change the status of the onos_lamp_node_WLightSA lamp status will be: 

  3 bytes with "[S_" for the start of the message
  3 bytes for the address of the node
  2 bytes containing "wl" for the type of msg , command wireless lamp node
  1 bytes for the number of the object to controll  (for first object of the node it will be "0" and it will be lamp status)
  1 byte to tell arduino the value (0 or 1 ) to set the object
  1 bytes for the message id ,a progressive binary number from 0 to 255
  3 bytes with "_#]" to close the message 
  example:   [S_001wl01x_#]    to set the first object of the node to 1
             [S_001wl00x_#]    to set the first object of the node to 0




  The message to change the value of a generic object node will be: #to implement

  3 bytes with "[S_" for the start of the message
  3 bytes for the address of the node
  2 bytes containing "do" for the type of msg , set digital object
  1 bytes for the number of the object to change  expressed in hexadecimal(for first object of the node it will be "0")
  1 byte to tell arduino the value (0 or 1 ) to set the object
  1 bytes for the message id ,a progressive binary number from 0 to 255
  3 bytes with "_#]" to close the message 
  example:   [S_001do01x_#]    to set the first object of the node to 1
             [S_001do00x_#]    to set the first object of the node to 0



  The message to change the value of a generic object node will be: #to implement

  3 bytes with "[S_" for the start of the message
  3 bytes for the address of the node
  2 bytes containing "ao" for the type of msg , set analog object
  1 bytes for the number of the object to change  expressed in hexadecimal(for first object of the node it will be "0")
  3 byte to tell arduino the value to set the object to expressed in hexadecimal (min 0x000  max 0xFFF)
          in this way the value can range from 0 to 65535 (16 bit)
  1 bytes for the message id ,a progressive binary number from 0 to 255
  3 bytes with "_#]" to close the message 
  example:   [S_001ao1000x_#]    to set the first object of the node to 0  which is the  hex value of "000" converted
             [S_001ao10FFx_#]    to set the first object of the node to 255  which is the  hex value of "00F" converted





  If a node needs to get a free address from the OnosCenter it will write:

  3 bytes with "[S_" for the start of the message
  3 bytes for the address of the node ("001" for the arduino gateway)
  2 bytes containing "ga" for the type of msg
  4 byte with the fw version for example "5.23"
  12 byte to tell the node serial number
  1 bytes for the message id ,a progressive binary number from 0 to 255
  3 bytes with "_#]" to close the message 
  example:   [S_001ga3.05ProminiS0001x_#] 

  But if the node is a plug or lamp with sensors it will send:

  3 bytes with "[S_" for the start of the message
  3 bytes for the address of the node ("001" for the arduino gateway)
  2 bytes containing "ga" for the type of msg
  4 byte with the fw version for example "5.23"
  12 byte to tell the node serial number
  1 byte to tell the status of the node ( relay on or off )
  3 byte to tell the sensor value on A0  (lux for "lamp type" and maybe ampere for "plug type")
  3 bytes to tell how many minutes the relay have been stayed on since the node was powered on (will restart after 10 hours).
  1 bytes for the message id ,a progressive binary number from 0 to 255
  3 bytes with "_#]" to close the message 
  example:   [S_254ga3.05ProminiS00010167123x_#]     #lux=167  lamp is at 0 , 123 minutes on since boot  

   

  OnosCenter will then send a message with a : [S_254sa123ProminiS0001x_#]  to tell the node to set its address to 123 for example

             


  If a node needs to send the "I'm alive" sync message OnosCenter it will write:
  3 bytes with "[S_" for the start of the message
  3 bytes for the address of the node ("001" for the arduino gateway)
  2 bytes containing "sy" for the type of msg
  ///  removed because i know the fw from the last getaddress    //4 byte with the fw version for example "5.23"
  12 byte to tell the node serial number
  1 bytes for the message id ,a progressive binary number from 0 to 255
  3 bytes with "_#]" to close the message 
  example:   [S_001syProminiS0001x_#]      



  If the node that have to send a sync message is a lamp node or a plug node it will write:
  3 bytes with "[S_" for the start of the message
  3 bytes for the address of the node ("001" for the arduino gateway)
  2 bytes containing "ul" for the type of msg  (um stand for update lamp)
  ///  removed because i know the fw from the last getaddress    // 4 byte with the fw version for example "5.23"
  12 byte to tell the node serial number
  1 byte to tell the status of the node ( relay on or off )
  3 byte to tell the sensor value on A0  (lux for "lamp type" and maybe ampere for "plug type")
  3 bytes to tell how many minutes the relay have been stayed on since the node was powered on (will restart after 10 hours).
  1 bytes for the message id ,a progressive binary number from 0 to 255
  3 bytes with "_#]" to close the message 
  example:   [S_001ulProminiS00010167123x_#]     #lux=167  lamp is at 0 , 123 minutes on since boot  


////////////////////////////////////OLD... TO UPDATE/////////////////////////////////////////////////////////

  if a node needs to communicate a input status pin to onos it will write:

  1 byte with 't' for the modes (transmit data )
  2 byte for the number of pin  (for pin 13 it will send '13'  ,for pin 3 it will send '03')
  1 byte to separe the pin number from the value , it will be 'v'
  3 byte to tell onos the status (from  000 to 255) of the pin
  1 byte for 's' to indicate the start of the serial number
  12 byte to tell the node serial number
  1 byte for a flag  ,if flag=='f' then forward incoming message
  3 byte for node address (used only for the wireless nodes but included also in the ethernet nodes..)
  3 byte to close the message "_#]"

  example : onos_t04v001sProminiS0001f001_#]         to tell pin 4 is at 1  
            onos_t04v000sProminiS0001f001_#]         to tell pin 4 is at 0 
             
             


  if OnosCenter needs to tell a node to set its address to a the designed one it will write:
    
  1 byte with 'g' for the modes (set address )
  2 byte with 'ad' to indicate the start of the address
  1 byte with 'v'  to indicate the start of the new address
  3 byte with the new address to use for example 123

  12 byte to tell the node serial number
  1 byte for a flag  ,if flag=='f' then forward incoming message to implement..
  3 byte for node address (used only for the wireless nodes but included also in the ethernet nodes..)
  3 byte to close the message "_#]"

  example :  onos_gadv123sProminiS0001f254_#]           to get the next free address
             [S_ga0000523ProminiS0001fff_#]


     

  if a node needs to communicate a webobject status: todo
    
  1 byte with 'o' for the modes (transmit object status )
  2 byte for the number of the object status  (00 is the first webobject in the node...01 is the second..up to 99 obj in a node)
  1 byte to separe the object number from the value , it will be 'v'
  3 byte to tell onos the status (from 000 to 255)  
  12 byte to tell the node serial number
  1 byte for a flag  ,if flag=='f' then forward incoming message
  3 byte for node address (in this case the address should be "000" because that is the address to OnosCenter)
  3 byte to close the message "_#]"

  example : onos_o01v001sProminiS0001f000_#]         to tell that the second object of the node is at 1 
            onos_o01v000sProminiS0001f000_#]         to tell that the second object of the node is at 0  



  if a OnosCenter needs to communicate to a irBarrier the lamp webobjet assigned serial number and address:todo
    
  1 byte with 'A' for the modes (assign objects )
  2 byte for the number of the object status  (00 is the first webobject in the node...01 is the second..up to 99 obj in a node)
  1 byte to separe the object number from the value , it will be 'v'
  3 byte to tell the Ibarrier the address of the assigned lamp node (from 000 to 255)  
  12 byte to tell  the Ibarrier the node serial number of the assigned node(the lamp node)
  1 byte for a flag  ,if flag=='f' then forward incoming message  
  3 byte for node address of the irBarrier  
  3 byte to close the message "_#]"

  example : onos_A00v003sWLightSS0003f005_#] 
  To tell to the node Irbarrier with address 005 to change directly the webobject 00 of the node WLightSS0003 that has address "003"

////////////////////////////////////END OFF OLD TO UPDATE/////////////////////////////////////////////////////////




17) After the user click to set an output onos will have to wait some time before changing the button color , so the 
    user will not know if the button was clicked correctly.
 
    We can make a third webobject status that will be the waiting status with a different color and html
    from the other status, this status will be the 0,5  status


18) the last element of a list in the html menu' is covered by the back button:
     make a void element at the end of the html


19) Onos has to work from internet without the need of a dsl router with opened ports:
      we have to make a website with login where the users will connect in order to controll their onos systems.
      OnosCenter will connect to the website and give the list of changed webobjects , 
      the website will have to store a variable which tell the onoscenter if something has changed from the user input.
      If something did , then OnosCenter will download the full webobjectstatus and apply them.
      This every n seconds, if more than 20 seconds passed then the onoscenter is offline.
      The site will be made in php because all server has php ,python would be more easy though
      multiple sqlite databases will be used (one for each user)
      The data to pass between the 2 system are:
        object_dict{} , zoneDict{} , remote_status_change_list[] ,sync_messages[]
      Every data will be passed using a json structure

      Onos will contact  the online php script every n seconds passing the parameters.
      The first 3 parameters are always username , password and key,so the main php script will open the right database and write there the datas (each onos system will have a database)
      then it will ask fo the sync_messages[]  and if it is empty  will do nothing .

       


IMPORTANT !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

TO PREVENT DATABASE DOWNLOAD FROM BROWSER put a .htaccess in the site  directory with :

<Files ~ "\.d">
    Order allow,deny
    Deny from all
</Files>

<FilesMatch "\.d">
Deny from all
</FilesMatch>



      The onos system database structure will be:

    $db->exec("CREATE TABLE if not exists onos_user (onos_username VARCHAR(40) PRIMARY KEY,user_password VARCHAR(40),onos_db TEXT )" );

$db->exec("CREATE TABLE if not exists onos_sys (onos_key TEXT PRIMARY KEY,onos_password VARCHAR(40),hw_fw_version TEXT,last_sync_time VARCHAR(16))" );

$db->exec("INSERT INTO onos_sys (onos_key,onos_password,hw_fw_version,last_sync_time ) VALUES ('$key','$pass','$hw_fw_version','00:00:00')");

$db->exec("CREATE TABLE if not exists zones (zone_name VARCHAR(40) PRIMARY KEY,zone_objects TEXT,zone_order INTEGER , zone_owner VARCHAR(40) ,zone_permissions VARCHAR(16) )");

$db->exec("CREATE TABLE if not exists web_objects (obj_name VARCHAR(40) PRIMARY KEY,obj_status TEXT,obj_style TEXT , obj_html TEXT ,obj_type VARCHAR(40),obj_permission VARCHAR(16),obj_group  VARCHAR(40),obj_priority INTEGER  )" );


$db->exec( "CREATE TABLE if not exists changed_remote_status_dict(changed_remote_status_dict_id INTEGER PRIMARY KEY,remote_status_dict TEXT)");


$db->exec("CREATE TABLE if not exists sync_messages (cmd_id INTEGER PRIMARY KEY,cmd_message TEXT)");



       every time i need to read or write list in a sqlite row i will use json to read or write! 

       to sync the webobjects and the zones  the online db will always answer to the query update with :
       the list of zone names , the list of weboject names , the list of weboject status.
       if the OnosCenter found that an online list is different from the local one , it will force a full update with a post query:
             
       

       The user will have a sync button to force the sync of all data.  (to implement )

       The onos center will download new version of the firmware if there is a cmd in the sync_messages (to implement )


20) Onos need to be controlled by mail

      A mail system will be avaible(activable from web interface) 
      so if the user onos mail receive a mail with :

      onos=  arguments separed by ","
 
      example:
      onos=usr:onos_usr,pw:onos_pw,cmd:so,arg:lamp0,st:0,

       # example : onos=cmd:so,arg:button1_RouterGL0000,st:1,      note the end ","  must be used


      The password used to controll onos from mail will be different from the one used for local webinterface
      for security reasons.
      onos will parse the cmdcode and if the password is correct will execute it.
      Onos will be able also to use a white list mail , from which will accept command without password  
      Using the mail_log in each webobject and scenario onos will write to the mail if there is a change in the status.
      with analog value there will be a threshold setted by mail

      The user can also send multiple commands ,he has just to make a new line for each command. 





      the user password to control onos from mail will be stored in usersDict["onos_admin"]["mail_control_password"]
      the list of mail from which onos will accept command without password  will be a list named mail_witheList

      type of cmd:

      so to set object
   
      ro to read object

      log_obj1 will active log mail on the object or scenario

      log_obj0 will disable log mail on the object or scenario

      en_scen will enable a scenario

      ds_scen will disable a scenario
      
      r_scen to read a scenario (conditions ..)


      argument:

        "all" will include all the obj or scenario  the user can use 
 

      
      mail cmd examples (onos_usr is the username, onos_pw is the password):
     
      hypothesizing the user has the execute permission on the object
      
      mail="onos=usr:onos_usr,pw:onos_pw,cmd=so,lamp0=0" will set the webobject  lamp0 to 0 if the username and password are right 
      mail="onos=so.lamp0=0" will set the webobject  lamp0 to 0 if the mail is in the whitelist 
      mail="onos=onos_usr.so.lamp0=0" will set the webobject  lamp0 to 0 if the mail is in the whitelist 
      mail="onos=onos_usr.so.lamp0=0.priority:9" will set the webobject  lamp0 with a "9" priority


      hypothesizing the user has the read permission on the object

      mail="onos=onos_usr.ro.lamp0" will write back a mail with the status of the  lamp0 webobject 

      mail="onos=onos_usr.ro.all#" will write back a mail with all the names and status of the webobject the user has the permission to read.




      mail="onos=onos_usr.st_scenario.all" will write back a mail with all the names , status (enabled or not) and conditions to set of the scenarios the user has the permission to read.

      mail="onos=onos_usr.en_scen.scenario_name=1" will enable the "scenario_name" scenario if the user has the execution permission on this scenario

      mail="onos=onos_usr.en_scen.scenario_name=0" will disable the "scenario_name" scenario if the user has the execution permission on this scenario

      mail="onos=onos_usr.log_obj1.lamp0" will check and write back the each change of status of this webobject, if the webobject is digital   

      mail="onos=onos_usr.log_obj1.temperature0.20" will check and write back the status each time it change by 20 from last mail

      

     
21) Is not possible to connect to the OnosCenter webpage from the wan port :
    opened the router firewall port



22) Sometimes a button remains in pending operation also if the nodes executed the action :
    implemented the queue system in order to avoid making webserver url query to change button status from the nodes
    each new node will have a queue where router_handler will put the change to be done in the webobjects status
    the webserver will check continuosly all the queues and make the changes
    Each element of the queue will contain a dictionary:

    to change all the webobjects status that have the node and the pin given:
    layerExangeDataQueue.put( {"cmd":"setNodePin","node_sn":"node_serial_numb","pinNumber":pin,"status_to_set":"the value of the status","write_to_hw":"1  to write to hardware 0 to change only the webobject status" } )
    
    example:
     layerExangeDataQueue.put({'setNodePin': 21, 'status_to_set': 1, 'cmd': 'pinNumber', 'write_to_hw': 0, 'node_sn': 'RouterGL0001'})



    to change a webobject status by name :

    layerExangeDataQueue.put( {"cmd":"setSts","webObjectName":"the web object name","status_to_set":"the value of the status","write_to_hw":"1  to write to hardware 0 to change only the webobject status"  })

    

 

     
     



hardwareModelDict["RouterGL"]={"hwName":"RouterGL","max_pin":5,"hardware_type":"gl.inet_only","pin_mode":{}}




23) How to make sure onos webserver stays always online : (banana not implemented yet)
    make a demon in onos.sh that will check every tot seconds if the webserver is answering  from local query 
    and also from internet query. 
    If the webserver is not answering the process will be killed , the onos configuration saved and the python script 
    will be exeecuted again, if after 2 minutes the webserver doesn't answer onos will be switched to recovery mode
    with the default configurations. 
    if there is non internet connection a query to the onos node connnected to the router will ask it to power off 
    the router and power on it after 1 minute



24) How to make a system where if a webobject change to a status then other webobjects change status as well:
    Scenarios:

     Add a dictionary  scenarioDict{} in globalVar.py where all the operation for all the webobject will be stored.
     Each webobject which is part of an operation will have a list of the scenarioDict{} keys  (the names of the scenarios) so it will check the  instruction and execute it at each status change   
    
     add a webobject called hours  which will contain the hours of the current clock  
     add a webobject called minutes  which will contain the minutes of the current clock  
     add a webobject called day  which will contain the calendar number of the day 
     add a webobject called month  which will contain the calendar number of the month 
     add a webobject called year  which will contain the calendar number of the years 
     add a webobject called dayTime  which will contain the hours of the day expressed in minutes


     all the time update will be made in  the hardwareHandlerThread() thread

    
     the scenarios will have a flag  "one_time_shot" which if true disable the scenario after the first run
     

     to evaluate the conditions i will use eval(string_condition)
     in both cases i will allow only certain characters input  and replace the webobjects name with their status value
     note if in the condition there is a webobject with a pending status the scenario will not be executed




     scenarioDict["change_lampobj"]{"enabled":1,"after_execution_mode":"","conditions":[cond1&cond2|cond3],"functionsToRun":[lamp1=0,lamp2=#_lamp2_#+1...],"afterDelayFunctionsToRun":[],"delayTime":0,"priority":0}
                                        
                                        
     ###inside "status" you put the status that the obj will be set to if the condition is true
     inside web_obj_to_read you put a list of weboject that will be readed and used in the  conditions from this scenario
     i need this list because i will replace all the names in the conditions with the values of the webobject      

     inside conditions put a string where to insert a webobject name you have to write  #_webobjectname_#
      so "#_webobjectname_#" will be replaced by the webobjectname status value
      the condition may have how much () you want  like : 
       (#_webobjectname1_#==1)&( #_webobjectname2_#==0)|( #_webobjectname3_#==#_webobjectname2_#) 


      if you want to use the obj previous value write #p_webobjectname_#

 
     #deprecated inside the actType you put the type of set , if is "delay" then will tell to the timer to set the obj to "end_status" after n minutes
     inside functionsToRun you put a list of the actions to be made when the conditions are true
     inside afterDelayFunctionsToRun you put a list of the actions to be made when the delay time is finish
     inside priority you put the priority of the scenario , default is 0  , put 6 if you want this scenario to overcome 
     all other scenarios and normal user actions

     #deprecated if the actType is delay then the functionsToRun instruction will be executed immediately and a new scenario
     with the afterDelayFunctionsToRun inside the  functionsToRun , with autodelete=1  and with the conditions setted as   
     dayTime> (#_dayTime_#-delayTime) will be created

     #deprecated  if the actType is "nodelay"  the webobject will be setted to "status" immediately 

    
     if "enabled"  is 1 then check and execute the scenario , else the scenario is disabled
     if "after_execution_mode="one_time_shot" disable the scenario part containing this flag after the execution 
     if "after_execution_mode="autodelete"then the scenario will be deleted from the the dictionary after the first execution

     if the user want to use the previous status of a webobject in the condition 
        he can write #p_webobjectname_#  and onos will use the previous status of that webobject  


     the conditions  will be checked only if one of its component changed its status 
     the operations  will be executed only if one of its component changed its status 



     ###the scenarios could be enabled and disabled from timer schedule


     action the scenario could make:
   
       set or reset a webobject status ( 0 or 1 )
       set a webobject status to a costant value
       set a webobject to the status of another webobject
       set a webobject to its status+1  (or +n)
       set a webobject to its status-1  (or -n)
       to negate a object status you could use :
   #    "not #_webobjectname2_#"this will replace the value with 0 if the value was 1...

       if in the functionsToRun you write  #_webobjectname_#=0
         webobjectname will be readed as a webobject name and this webobject will be setted to 0

       if in the functionsToRun you write  webobjectname=#_webobjectname2_#
         #val_webobjectname2_# will be replaced by the value of the webobjectname2 status
         so the webobject will be set to that value

       if in the functionsToRun you write  webobjectname=#p_webobjectname2_#
         #val_webobjectname2_# will be replaced by the previous value of the webobjectname2 status
         so the webobject will be set to that value


      i will use regular expressions to replace the parts:

      scenario_conditions=re.sub(r'#_.+?_#',lambda x: str( object_dict[x.group(0)[2:-2]].getStatus()),scenario_conditions)



      NOTE: never add the scenario name to  minutes object while using the dayTime obj as scenario condition:
            this will gave you a delay of 1 minute in the scenario execution because minutes change before dayTime...

            now if a delay of 1 minute is called , then the execution happen on the change of the minute 
             so if there are 10 seconds before the next minute , the delay will be 10 seconds instead...


            the time could be checked inside the     while not layerExchangeDataQueue.empty(): loop 
            if needed  (to implement?)
            or a thread with a delay could be created inside the scenario check

             



 



25) What happen if a webobject is setted from the users from web interface  but there is a scenario that want to control the webobject as well?

  The permission system will be:
   owner  group_users  scenarios
   rwx    rwx         rwx
   read,write,execute               
   where:
     read means read the webobject status
     write means modify the webobject 
     execute changes its status 
   
   so 777 will set rwx to all the user and to all scenarios

   each webobject has a owner list of username who can modify the webobject  


  There are scenarios with the maximum level priority like the security ones .
  each scenarios will have a priority level  that  range from 0 to 10  where 10 is the top priority and 0 is the lowest 
  5 will be the default scenario priority.
  if a scenarios has the priority set to 10 it will be able to make everything on a webobject regardless the permission of the webobject.
  only admin can set a scenarios priority to 10  ,the normal user will be able to set it up to 9(banana to implement)
  if any scenario action is in conflict with another  , the action performed will be the one from the scenario with greater priority.
  when a webobject status is changed ,onos will write in the webobject  priority_action  the value of the priority that 
  has changed the object status.
  In order to change again the status the next change must be made from a priority level equal or greater than the previous.
  The normal user will have a priority of 5  while an admin user could have a priority of 10 (by default is always 5)
  if  a priority of 99 is setted this will allow the execution but will not increase the object priority after it     
 







  All the webobjects will have a owner value list where there will be the user owner names 
  by default the webobject created from onos will have a user owner called "onos"
  by default all webobjects permission will be set to 777  , access to every one
  by default all webobjects will have a permission_timout of 5 minuts after that all the scenario with that webobjects as output will be checked if a manual change occured


  the scenarios will be able to change webobjects permission 

  each webobject will have a Permissions value , if the permissions value from the method is tring to set the status of the webobject is compatible with the object permissions value then the webobject will be setted , otherwise it will not.
  The standard webobject will have default permissions value of 777 (The file's owner may read, write, and execute the file. All others may read and execute the file) .
  if a user set a webobject ,its permissions will change to 770 so the scenarios will find the 0 and will not be able to change the webobject.

  Each webobject will have a status_before_manual_change value where the status before the manual change will be stored.

  The user will be able to choose for each object the behavior.
  there will be 2 type of behavior : 
     the first is the status_before_manual_change based one
     the second is the timer one


  In the first mode, after the manual change the scenarios will not be able to change the webobject until the user
  changes the status back to the original (before the first manual change) 
  Or until another scenario changes the permission of the webobject
 
  In the second mode, after the manual change the scenarios will not be able to change the webobject until a time chosen by the user in the webobject setup, after that time the webobject 
  permissions  will be restored to 777 and the scenarios will be able to set it


  So if a webobject is changed by the user and then a scenario tries to change it , the object will not change because the permission of the senario is lower than the user ones.
  In the case a webobject is controlled by hand from the user the permission of the webobject will change to 770




26) Need to ensure no one except the user can controll the webobject :
    block ssh from wan
    the webobjects will be under a different network connected to the onosCenter , using iptable to block external contact
    Study iptable to open only port 80 to the outside ...so the webobjects will be controlled only by webinterface ,
    so with password. 



27) Onos Login page :
    After the login onos will save the ip and username of the user and check every n minutes (logTimeout) if the user is active
    (updating user_active_time_dict[user_ip]= [username,timeNow] after every request)
    if  (timeNow> user_active_time_dict[user_ip][1]+logTimeout) ---> logout

    The check will be made on every webpage request and if the user is not logged anymore onos will redirect him to
    the login page.
    If the user has not the permission to view a section ,this section will be hidden  (private zones..)
    Usernames and password will be stored in a dict -->>   usersDict[username]=password     



28) Make onos multilanguage : banana to implement
    There will be differents json files which will contain all the texts for all the languages 
    Onos will load in memory only the one needed as a dictionary  where the key will be a english string describing the page , inside this dictionary there will be a list of strigs.
    example:
    languageDict["start_page"]=("play","info","setup")
    in the start_page there is 3 string  ...the first one is "play"
    
    

29) The javascript update page fail to update if there is a lost connection just one time


30) The user don't have to have a list of all the nodes in the zones webpage :banana to implement

     a GENERIC  "allNodes"   zone will be created with all the webobject created from the nodes.
     Hide or not create a zone fo each node



31) I need to make possible for the user to  hide and to order the zones ,and the zones has to be accessible following the onos permission system (rwe):#banana the core is done but there is the gui part left..

  The zone dict will be structured in the following way:
  The dictionary key will be the zone name  
  The dictionary data ,will be a dictionary itself, having this keys:  
    "objects" : a list of all webobjects names 
    "order"     the position of the zone when all zones are to be displayed  ,int 0 is the first 
    "permissions"  the linux style permission   "777"  
    "group"    a list of names used by the permission system
    "owner"    the owner name of the zone
    "hidden"   0 or 1  if true will hide the zone from all the users  (only in the play section of the webpage interface )
 
   zoneDict[node_sn]={"objects":[],"order":zoneDict.keys(),"permissions":"777","group":[],"owner":"onos_sys","hidden":0}
   sortZonesByOrderNumber()



32) I need to allow other people to develop a onos gui:
    Created the cgi folder, every python script there could be executed as part of the main webserver.
    When the user insert in the browser   : onosip/cgi/pythonScriptName.py 
    the "pythonScriptName.py" will be executed and the variable "web_page"  will be served to the browser.
    so if inside pythonScriptName.py  you write   web_page="hello world"  this will be printed on the webpage
    Note that all the global variable are accessible from the external python script.



33) Onos must have a way to update itself to the latest version , from internet and also from local:banana to implement

    A python script (update_check.py) will be executed before the onos script from "onos.sh"!.
    this python will search for a folder "onos_update" in the main onos folder (on the flash).
    if the folder does exist (and the md5sumis is right)then the onos will execute the "onos_update.py"
    in that folder ,which will check if there is enough free ram space.
    If so it will download (in ram) the tar with all the new onos files, check if the md5sum is right and then 
    extract them in ram and then will replace them to the old ones in the flash.
    After that the script will remove the directory onos_update and run the main webserver.
    if you power off before all the files are moved the directory will be still there and at the next reboot onos will 
    try to update itself again!



    the first file that will be downloaded will contain the current online fw version the hw type and the total number of files to download
    if the fw version is the same as the one in the fw_version.txt (which will like 5.15_GLINET#files:226#)
    Onos will know that the fw is updated.
    Otherwise will download all the files,and after that if the file number is the same indicated in 
    the downloaded fw_version.txt , onos will replace all the old files with the new ones.
    Then will replace the fw_version.txt and remove the "onos_update" folder

    To update the system onos will delete all the directory but these:
    /scripts_folder/cgi
    /scripts_folder/config_files
    /scripts_folder/zones
    
    The files in these directories will not be replaced with the new ones (so if the user had created some files this will not deleted )

    if at the boot onos found the folder "onos_update" because it was not deleted  , then will update all
    because probably something went wrong with the previous update
   
    Note that the script "onos.sh" will never be updated

    The update files must never be too big because otherwise the filesystem will have problems
    The "onos_update" folder can be downloaded  automatically by the system (enable_onos_auto_update="yes" in globalvar.py and cfg.json) or the request to update could be sent manually from the web interface (stil to implement banana)

    To implement a simple web server at startup wich allow you to upload the fw from browser.. 


34)  Onos must know if a node isn't working or powered off , and lets the user know it as well:
     each node will ask the setup to onos every n minuts , so onos will wait and set as inactive every node 
     that will not ask the setup for more that n minuts .
     For sensible node like antitheft sensors the timeout might be 30 seconds
     The variable is_active will be stored in each webobject of the node and will be usable in the scenarios (banana not implemented yet)
     Each node will have a variable called "last_node_sync" (setted using the funcions updateNodeAddress() and then updateLastNodeSync()) which will store the last time the node ask the setup to onos
     a variable "isActive" which will tell onos if the node is active and a variable called "timeout" which will set the time without contact after onos will set the node as not active.
     The inactive webobjects will have a white color in the onos interface 
     and their status will be setted to the string "inactive"
     After the node is connected again all the webobjects will be setted to the status previuos the disconnection  
     Each node "timeout" will be loaded from hardwareModelDict{}    


35)  Sometimes the communication with a node fail :  #to implement?
     In order to have one and only one query for each node , a query handler will be implemented.
     Passing node_address,query,objName,status_to_set,user,priority,mail_report_list
     If different queries are to be done to the same address , they will be added to a list and then excuted one after one 
     ###not to implement?? Each request will have a priority , the next query to be done will be the one with the greatest priority number (from 0 to 10 ,99 will be replaced by 10)
     ###not to implement??####If the request query is lesser than 10 then the query will be tried 5 times before passing to the next one(for te same node),the query will not be removed from the list and will be retried other 15 times.. if the priority is 10 the query will be repeated 20 times before giving up 
     
 

35b)  After the implementation of point 35 the stability problem of connection is still there:
     Change the way onos talks to the nodes using pure tcp message without http protocol ..
     each tcp message will end with  "_#]"
     




36)  Onos must has a way to tell what is going on to the user:#banana to implement
     A webpage where the log is printed will be created 


37) The user must be able to create new username account inside the local onos interface: 
     (for security reason this part will be avaible only in the local interface)
    The interface will ask an username , a password and a mail .
    After that it will check if there is internet connection ,otherwise will rise error and tell the user to connect it (advanced users that don't use internet with onos will have to modify the json to create local users)
    After the user iserted the data onos will check if the username exist yet in the online database , if yes it will tell the user to use another username.
    If the username is new then onos will add it to the online database and then add to the local usernames.

    There will be a gui to handle each users permission and to delete the usernames, only admin will have access to it



 


38) The current serial number format for example "ProminiA0007"  support only 9999 producted objects because to the final node I ha ve to pass only the numeric value...
    changed, now i send the full serial number so I will have 9999 products for each category..





39) I need to control lamps sockets and lamps, but the powerline hardware is too big to fit in a bulb or lamp socket, so I will develop a radio network based on RMF69 radio modules.


40) I need to control the radio modules from the onosCenter :
    The simple way is to connect an arduino to the onosCenter and then make it router all the messages betweens the nodes and the onosCenter.

    To do so I implemented :
   
    Serial_connection_Handler.py : It will handle the usb serial connection and usb reconnection.

    arduinoserial.py: It will setup the proper serial configurations and read and write the data from the serial port.


    To control the arduino connected to the serial port I used  onos_rf69_serial_transponder.ino program on the arduino.

    The protocol will allow also control over the local pin  like it was a simple remote node.

    To write to the serial node (to change its pins) you must select the "001" address like this: onos_d05v001sProminiS0001f001_#]


41) To solve problem in the tx rx of the radio network this will be the flow:
    The arduino gateway  will listen to the serial, if there is no messages there it will listen to the radio for incoming data(in Promiscuous mode???)
    if there is an incoming radio data it will try to decode it, if is it a valid data it will send the ack to the tranmitter
    and then the data will be passed to the OnosCenter by serial port (with 6 retry ,retry not implemented).
    Note that in this way the nodes will not have the assurance that the data has been received from the OnosCenter..



    If there is an incoming data on the serial port the arduino gateway will decode it and if necessary the data will be sent to
    a remote node.
    At this time the onos weboject will not be changed yet (it will be still in wait status)
    When the final node received the message it will decode it and change the node status , then it will send the ack message.
    at this point the arduino gateway will tell the OnosCenter the operation was successfull sending "ok"+the packet sent
    #If during the final node don't ack the message the arduino gateway will retry sending it 10 times with a delay between try.
      #after 10 times it will giveup.
    During this phase (while the gateway is writing to a node or waiting answer from a node or receiving a message from the OnosCenter , any messages from others nodes will be ignored so they will retry to contact the node for 5 times and after that they will giveup (some nodes will have precendence and will also retry a number of time greater than others for example the allarm nodes)

    Forse si può modificare per permettere il multithread...al momento devo aspettare che il modulo 232_To_radio faccia tutti i tentativi di trasmissione radio prima di iniziare a fare i tentativi per contattare il prossimo nodo radio..magari si può far gestire ad onoscenter il reinvio dei tentativi e fare un solo tentativo per query...in questo modo onoscenter può fare una richiesta , se fallisce può contattare un altro nodo e poi riprovare con il precedente! senza bloccarsi!  (nota mettere comunque timeout se passano più di 2 minuti dal comando all'attuazione è sconveniente...)
    



42) What if a node needs to control another node directly?for example the ir barrier should control directly the room lamp..Todo
    In this case the node will ask the other node to change the status directy.
    The receiving node (for example the lamp) will send the ack and then wait in a non blocking mode with millis() for a small time 
    after that it will write to the OnosCenter to update its status.



43) How to handle the smartlamp node with the ir node to turn on and off a room lamp based on the persons in the room: Todo
    For this example we assume that the room has one lamp and 2 doors with ir barrier.
    When a person enter the room the ir barrier will tell the lamp to increase the persons number in the room (value stored in the lamp node) if the value is >0 and the light in that room is lesser than a certain level , then if the lamp is off it will turned on.
    If then the person exit the room from the other door the other barrier will send a -1 to the lamp and if there are 0 persons in  the room the light will be turned off.

    To customize the ir barrier direction there will be a dip switch which will tell the barrier in what direction it will add persons ..

    To assign the variuos ir barrier to the lamp there will be a setup page in onos where you assign a webobject to the irbarrier.
    Then the OnosCenter will send a message to the irBarrier to tell it the lamp serial node and address assigned.
    And will send that message also if the lamp node change its address..


    Every lamp node will have an inside logic to handle the persons count and to turn on the lamp..

 

     


44) Node parameters:   Todo

    Each node will have number of variables (objects) that can be changed from onos throught radio.
    Onos will know from the node type which object number refer to which variable for example in the lamp node the object number 0 will be the value of the lamp relay.

    For example a lamp node could have :
      A ligth threshold  (how much light will be needed to turn off the lamp)
      A counter value (enabled only if an iRbarrier or other sensors are associated) to tun on the lamp if >0
      A timeout value after that the lamp will shut down assuming noone is still inside.
      A light sensor value (the analog reading from the photoresistor)
      A current sensor (to read the power consumption of the lamp)
      This webobjects will be stored in hardwareModelDict{}
      for example:  
        hardwareModelDict["WLightSS"]["var_mode"]["numeric_var"]={"ligth_threshold":[(5)]} in this case 5 is the threshold value
        hardwareModelDict["WLightSS"]["var_mode"]["analog_input"]={"ligth_sensor":[(6)]} in this case the 6 is the analog pin number
     
       The objects in the  "var_mode" dictionary will not be shown in the node zone created by onos,
         the user will see them in general node weboject list
       

  

 


45) Node addresses assignment:
   When powered on a wireless node set its address as 254 and then ask to the arduino gataway a new address (with retry =10),
   The arduino received the request and pass it to OnosCenter which will create the node in the dictionary and then anwswer with the
   new node address and the serialnumber of the destined node 
   Then if some special setup message is needed , OnosCenter will wait a bit and then send it.
   The message the node will send to ask a address will be:

   



46) Lamp hardware, how to implement it? :
   The enclosure will be the one from lithium led lamps
   The lamp will have a photoresistor to detect the lumos of the room
     It will have also a connector to update the onos firmware.
   Each time the lamp turns on the micro will read a flag in the eprom
   then it will turn on the lamp if the previous status is 0 ,then it will write the status in the eprom and send the status to onos.
    



47) Need a way to make custom node query:

   3 new object types are added:

   digital_obj    : handled on the node arduino firmware side
   analog_obj     : handled on the node arduino firmware side     
   cfg_obj        : handled on the node arduino firmware side, will be hidden in the created zone but avaible in the config...
   
   To define the query that will be sent to the node there will be a placeholder like this:

   hardwareModelDict["WPlugAvx"]["query"]["digital_obj"]={"plug":"wp#_objnumber_##_valuelen:1_#"}  #define the base query for this

   where:
   wp is the cmd_type  
   #_objnumber_# will be replaced by the progressive number of the object in the node..for example in  a single plug it will be '0' 
   #_valuelen:1_# will be replaced by a number (1 char long) to rappresent the value of the object  
   

48) What happen if two  neighbors persons buy 2 onoscenter ?The systems will interfer with each others?
    We need to implement a way to pair the network of radio modules with each onoscenter. 
    Partial solution, every time we sell a new node we will ask the customer for they onosUsername and from the online server we will extract the key password for that onoscenter.
    To implement a variable password set from the onoscenter to the radio transciver ...and the web interface to get the password from local and from remote webpage.


49) How can a lamp node tell onos how much time has been turned on in a day?to solve later... todo


50) How can a node send the status of an object that has changed?todo
    the node will send a syncmessage where it will tell onos the number of the objects it will send,the type of the object(to know how many bytes it will use) , the number of each object followed by the value of that object (variable byte lenght based on the type of obj that onos will get from the hardwareModelDict in globalVar.py) 





